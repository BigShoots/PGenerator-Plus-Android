package com.pgeneratorplus.android.hdr

import android.media.MediaCodec
import android.media.MediaCodecList
import android.media.MediaFormat
import android.util.Log
import android.view.Surface
import java.nio.ByteBuffer

/**
 * Creates a MediaCodec HEVC decoder with HDR10 profile to trigger the
 * Amlogic display pipeline to enter HDR output mode.
 *
 * On devices like Chromecast with Google TV, the HWC only supports HDR
 * through the video decoder pipeline. GPU-rendered content (OpenGL) can
 * set BT2020_PQ dataspace on the buffer, but the HWC rejects it for
 * hardware overlay (DEVICE composition) and falls back to GPU composition
 * (CLIENT) in SDR colorspace.
 *
 * By creating a hardware HEVC decoder with HDR10 color parameters and
 * decoding a single frame to a Surface, we trigger the video HAL to switch
 * the HDMI output to BT2020 PQ (HDR10). Once the display pipeline is in
 * HDR mode, the OSD layer (where our GPU patterns render) also benefits
 * from the HDR output — our BT2020_PQ dataspace is respected.
 *
 * The decoded frame is a solid black 128x128 10-bit HEVC frame that's
 * invisible when our pattern covers the full screen. The decoder stays
 * alive to maintain the HDR output state.
 */
class HdrVideoOverlay {

 companion object {
  private const val TAG = "HdrVideoOverlay"
  private const val MIME_HEVC = "video/hevc"
  private const val WIDTH = 128
  private const val HEIGHT = 128

  // Minimal HEVC HDR10 bitstream generated by ffmpeg:
  //   ffmpeg -f lavfi -i "color=black:s=128x128" -frames:v 1 -c:v libx265
  //     -profile:v main10 -pix_fmt yuv420p10le
  //     -x265-params "colorprim=bt2020:transfer=smpte2084:colormatrix=bt2020nc:
  //       range=full:repeat-headers=1:annexb=1" -f hevc
  //
  // CSD = VPS (NAL 32) + SPS (NAL 33) + PPS (NAL 34)
  // Contains: Main10 profile, BT.2020 primaries, SMPTE ST.2084 PQ transfer,
  // BT.2020 NCL matrix, full range, 10-bit, 128x128
  private val HEVC_HDR10_CSD = byteArrayOf(
   0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0C, 0x01,
   0xFF.toByte(), 0xFF.toByte(), 0x02, 0x20, 0x00, 0x00, 0x03, 0x00,
   0x90.toByte(), 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
   0x1E, 0x95.toByte(), 0x98.toByte(), 0x09, 0x00, 0x00, 0x00, 0x01,
   0x42, 0x01, 0x01, 0x02, 0x20, 0x00, 0x00, 0x03,
   0x00, 0x90.toByte(), 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
   0x00, 0x1E, 0xA0.toByte(), 0x10, 0x20, 0x20, 0x4D, 0x96.toByte(),
   0x56, 0x69, 0x24, 0xCA.toByte(), 0xF0.toByte(), 0x16, 0xE1.toByte(), 0x22,
   0x01, 0x20, 0x80.toByte(), 0x00, 0x00, 0x03, 0x00, 0x80.toByte(),
   0x00, 0x00, 0x0C, 0x84.toByte(), 0x00, 0x00, 0x00, 0x01,
   0x44, 0x01, 0xC1.toByte(), 0x72, 0xBC.toByte(), 0x22, 0x40
  )

  // IDR_N_LP frame (NAL type 20) — solid black 128x128 10-bit (PQ)
  private val HEVC_HDR10_FRAME = byteArrayOf(
   0x00, 0x00, 0x00, 0x01, 0x28, 0x01, 0xAF.toByte(), 0x1C,
   0x34, 0x6E, 0xF7.toByte(), 0x11, 0xFF.toByte(), 0xFF.toByte(), 0x80.toByte(), 0x74,
   0x55, 0x1E, 0x00, 0xFE.toByte(), 0x89.toByte(), 0x94.toByte(), 0xA1.toByte(), 0x23
  )

  // Minimal HEVC HLG bitstream — same as HDR10 but with
  // transfer_characteristics=18 (ARIB STD-B67 / HLG) instead of 16 (PQ).
  // Generated by ffmpeg with: transfer=arib-std-b67
  //
  // CSD = VPS (NAL 32) + SPS (NAL 33) + PPS (NAL 34)
  // Contains: Main10 profile, BT.2020 primaries, ARIB STD-B67 HLG transfer,
  // BT.2020 NCL matrix, full range, 10-bit, 128x128
  private val HEVC_HLG_CSD = byteArrayOf(
   0x00, 0x00, 0x00, 0x01, 0x40, 0x01, 0x0C, 0x01,
   0xFF.toByte(), 0xFF.toByte(), 0x02, 0x20, 0x00, 0x00, 0x03, 0x00,
   0x90.toByte(), 0x00, 0x00, 0x03, 0x00, 0x00, 0x03, 0x00,
   0x1E, 0x95.toByte(), 0x98.toByte(), 0x09, 0x00, 0x00, 0x00, 0x01,
   0x42, 0x01, 0x01, 0x02, 0x20, 0x00, 0x00, 0x03,
   0x00, 0x90.toByte(), 0x00, 0x00, 0x03, 0x00, 0x00, 0x03,
   0x00, 0x1E, 0xA0.toByte(), 0x10, 0x20, 0x20, 0x4D, 0x96.toByte(),
   0x56, 0x69, 0x24, 0xCA.toByte(), 0xF0.toByte(), 0x16, 0xE1.toByte(), 0x22,
   0x41, 0x20, 0x80.toByte(), 0x00, 0x00, 0x03, 0x00, 0x80.toByte(),
   0x00, 0x00, 0x0C, 0x84.toByte(), 0x00, 0x00, 0x00, 0x01,
   0x44, 0x01, 0xC1.toByte(), 0x72, 0xB4.toByte(), 0x22, 0x40
  )

  // IDR_N_LP frame (NAL type 20) — solid black 128x128 10-bit (HLG)
  private val HEVC_HLG_FRAME = byteArrayOf(
   0x00, 0x00, 0x01, 0x28, 0x01, 0xAF.toByte(), 0x1D, 0x80.toByte(),
   0xF7.toByte(), 0x01, 0x5B, 0xFF.toByte(), 0xF2.toByte(), 0x4E, 0xFE.toByte(), 0xC7.toByte(),
   0x00, 0x1F, 0xD1.toByte(), 0x32, 0x94.toByte(), 0x24, 0x60
  )

  // HDR10 static metadata (SMPTE ST.2086 mastering display color volume)
  // BT.2020 primaries, D65 white, 1000/0.001 nit luminance
  private val HDR_STATIC_INFO = ByteBuffer.allocate(25).apply {
   put(0x00) // Type: SMPTE2086 + CTA861.3
   // Display primaries (BT.2020) in 0.00002 units (little-endian 16-bit)
   putShort(java.lang.Short.reverseBytes(13250.toShort()))  // Gx = 0.265
   putShort(java.lang.Short.reverseBytes(34500.toShort()))  // Gy = 0.690
   putShort(java.lang.Short.reverseBytes(7500.toShort()))   // Bx = 0.150
   putShort(java.lang.Short.reverseBytes(3000.toShort()))   // By = 0.060
   putShort(java.lang.Short.reverseBytes(34000.toShort()))  // Rx = 0.680
   putShort(java.lang.Short.reverseBytes(16000.toShort()))  // Ry = 0.320
   // White point (D65)
   putShort(java.lang.Short.reverseBytes(15635.toShort()))  // Wx = 0.3127
   putShort(java.lang.Short.reverseBytes(16450.toShort()))  // Wy = 0.3290
   // Luminance
   putShort(java.lang.Short.reverseBytes(1000.toShort()))   // MaxLum = 1000 nits
   putShort(java.lang.Short.reverseBytes(1.toShort()))      // MinLum = 0.0001 nits
   // CTA861.3
   putShort(java.lang.Short.reverseBytes(1000.toShort()))   // MaxCLL = 1000
   putShort(java.lang.Short.reverseBytes(400.toShort()))    // MaxFALL = 400
   flip()
  }
 }

 private var decoder: MediaCodec? = null
 @Volatile private var isActive = false
 @Volatile private var keepRunning = false

 /**
  * Start the HDR video overlay decoder.
  *
  * Creates a hardware HEVC decoder with HDR10 parameters and continuously
  * decodes frames to the given Surface. This triggers the Amlogic display
  * pipeline to switch HDMI output to BT2020 PQ (HDR10).
  *
  * The decoder loops the same IDR frame continuously to keep the video
  * pipeline alive. Without continuous playback, the Amlogic HWC may not
  * trigger the HDR mode switch or may tear down the pipeline after EOS.
  *
  * @param surface The Surface to decode to (must be from a visible SurfaceView)
  * @param eotf EOTF mode: 2=PQ/HDR10, 3=HLG
  * @return true if the decoder started successfully
  */
 fun start(surface: Surface, eotf: Int = 2): Boolean {
  if (isActive) {
   Log.w(TAG, "Already active")
   return true
  }

  try {
   // Find hardware HEVC decoder
   val codecName = findHardwareDecoder()
   if (codecName == null) {
    Log.e(TAG, "No hardware HEVC decoder found")
    return false
   }
   Log.i(TAG, "Using decoder: $codecName")

   // Select CSD and IDR frame matching the requested EOTF
   val isHlg = (eotf == 3)
   val csdBytes = if (isHlg) HEVC_HLG_CSD else HEVC_HDR10_CSD
   val idrBytes = if (isHlg) HEVC_HLG_FRAME else HEVC_HDR10_FRAME
   Log.i(TAG, "Using ${if (isHlg) "HLG" else "PQ"} CSD (${csdBytes.size} bytes) + IDR (${idrBytes.size} bytes)")

   // Configure format
   val format = MediaFormat.createVideoFormat(MIME_HEVC, WIDTH, HEIGHT).apply {
    setByteBuffer("csd-0", ByteBuffer.wrap(csdBytes))
    setInteger(MediaFormat.KEY_PROFILE, 4096) // Main10HDR10
    setInteger(MediaFormat.KEY_COLOR_STANDARD, MediaFormat.COLOR_STANDARD_BT2020)
    setInteger(MediaFormat.KEY_COLOR_TRANSFER,
     if (eotf == 3) MediaFormat.COLOR_TRANSFER_HLG
     else MediaFormat.COLOR_TRANSFER_ST2084
    )
    setInteger(MediaFormat.KEY_COLOR_RANGE, MediaFormat.COLOR_RANGE_FULL)
    setByteBuffer(MediaFormat.KEY_HDR_STATIC_INFO, HDR_STATIC_INFO.duplicate())
   }

   Log.i(TAG, "Configuring decoder with format: $format")

   decoder = MediaCodec.createByCodecName(codecName).also { codec ->
    codec.configure(format, surface, null, 0)
    Log.i(TAG, "Decoder configured, starting...")
    codec.start()
    Log.i(TAG, "Decoder started, feeding frames continuously...")

    keepRunning = true
    var frameCount = 0L
    var presentationTimeUs = 0L
    val bufferInfo = MediaCodec.BufferInfo()

    // Feed initial IDR frame
    val initIndex = codec.dequeueInputBuffer(5000000) // 5s timeout
    if (initIndex >= 0) {
     val inputBuffer = codec.getInputBuffer(initIndex)!!
     inputBuffer.clear()
     inputBuffer.put(idrBytes)
     codec.queueInputBuffer(
      initIndex, 0, idrBytes.size,
      presentationTimeUs, MediaCodec.BUFFER_FLAG_KEY_FRAME
     )
     frameCount++
     presentationTimeUs += 33333 // ~30fps
     Log.i(TAG, "Initial IDR frame queued (${idrBytes.size} bytes)")
    } else {
     Log.w(TAG, "Failed to dequeue initial input buffer")
    }

    // Wait for first output to confirm decoder works
    var firstFrameRendered = false
    var initAttempts = 0
    while (!firstFrameRendered && initAttempts < 100) {
     val outputIndex = codec.dequeueOutputBuffer(bufferInfo, 100000) // 100ms
     when {
      outputIndex >= 0 -> {
       codec.releaseOutputBuffer(outputIndex, true)
       firstFrameRendered = true
       Log.i(TAG, "First frame decoded and rendered to surface")
      }
      outputIndex == MediaCodec.INFO_OUTPUT_FORMAT_CHANGED -> {
       Log.i(TAG, "Output format changed: ${codec.outputFormat}")
      }
      outputIndex == MediaCodec.INFO_TRY_AGAIN_LATER -> {}
     }
     initAttempts++
    }

    if (!firstFrameRendered) {
     Log.e(TAG, "Failed to decode first frame")
     keepRunning = false
    }

    isActive = true
    Log.i(TAG, "HDR video overlay active, entering continuous feed loop")

    // Continuous loop: keep feeding the same IDR frame to maintain
    // the video pipeline and HDR mode. Feed at ~2fps (low CPU usage).
    while (keepRunning) {
     try {
      // Drain all available output buffers
      var outputIndex: Int
      do {
       outputIndex = codec.dequeueOutputBuffer(bufferInfo, 10000) // 10ms
       if (outputIndex >= 0) {
        codec.releaseOutputBuffer(outputIndex, true)
       }
      } while (outputIndex >= 0)

      // Feed another IDR frame
      val inputIndex = codec.dequeueInputBuffer(10000) // 10ms
      if (inputIndex >= 0) {
       val inputBuffer = codec.getInputBuffer(inputIndex)!!
       inputBuffer.clear()
       inputBuffer.put(idrBytes)
       codec.queueInputBuffer(
        inputIndex, 0, idrBytes.size,
        presentationTimeUs, MediaCodec.BUFFER_FLAG_KEY_FRAME
       )
       frameCount++
       presentationTimeUs += 33333

       if (frameCount % 60 == 0L) {
        Log.d(TAG, "HDR video overlay: $frameCount frames fed")
       }
      }

      // Sleep ~500ms between feeds (2fps is enough to keep pipeline alive)
      Thread.sleep(500)
     } catch (e: InterruptedException) {
      break
     } catch (e: IllegalStateException) {
      Log.w(TAG, "Decoder in bad state, stopping: ${e.message}")
      break
     }
    }

    Log.i(TAG, "Continuous feed loop ended after $frameCount frames")
   }
   return true

  } catch (e: Exception) {
   Log.e(TAG, "Failed to start HDR video overlay: ${e.message}", e)
   stop()
   return false
  }
 }

 /**
  * Stop the HDR video overlay and release the decoder.
  * This may cause the display to exit HDR mode.
  */
 fun stop() {
  keepRunning = false
  try {
   decoder?.let { codec ->
    try { codec.stop() } catch (e: Exception) { /* ignore */ }
    try { codec.release() } catch (e: Exception) { /* ignore */ }
   }
  } catch (e: Exception) {
   Log.w(TAG, "Error stopping decoder: ${e.message}")
  }
  decoder = null
  isActive = false
  Log.i(TAG, "HDR video overlay stopped")
 }

 /**
  * Find a hardware HEVC decoder (prefer Amlogic vendor decoder).
  */
 private fun findHardwareDecoder(): String? {
  val codecList = MediaCodecList(MediaCodecList.ALL_CODECS)
  var fallback: String? = null

  for (info in codecList.codecInfos) {
   if (info.isEncoder) continue
   val types = info.supportedTypes
   if (types.any { it.equals(MIME_HEVC, ignoreCase = true) }) {
    val caps = info.getCapabilitiesForType(MIME_HEVC)
    val isHardware = !info.isSoftwareOnly
    if (isHardware) {
     // Prefer Amlogic decoder
     if (info.name.contains("amlogic", ignoreCase = true)) {
      return info.name
     }
     if (fallback == null) fallback = info.name
    }
   }
  }
  return fallback
 }
}
